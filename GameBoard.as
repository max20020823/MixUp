package {		import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;		/**	 * PRIMARY CLASS FOR MANAGING GAME STATUS AND RETAINING GAME HISTORY	 */		public class GameBoard extends Sprite {				static public var GAME_READY:String = "gameReady";		static public var GAME_OVER:String = "gameOver";		static public var PIECE_SWAP:String = "pieceSwap";		static public var PIECE_LOCK:String = "pieceLock";				protected var _pieces:Vector.<IGamePiece>;		protected var _rows:int, _columns:int;		protected var _imageWidth:int, _imageHeight:int;		protected var _boardImage:ISourceImage;		protected var _selectedPiece:IGamePiece;		protected var _pieceClass:Class;				public function GameBoard(boardImage:ISourceImage, pieceClass:Class, rows:int, columns:int, imageWidth:int = 0, imageHeight:int = 0) {			_rows = rows;			_columns = columns;			_imageWidth = imageWidth;			_imageHeight = imageHeight;			_boardImage = boardImage;			_pieceClass = pieceClass;		}				public function createBoard():void {			_pieces = new Vector.<IGamePiece>();			var numPieces:int = _rows * _columns;			var imageData:Vector.<BitmapData> = _boardImage.getImages(_rows, _columns);			for (var i:int = 0; i < numPieces; i++) {				var piece:IGamePiece = new _pieceClass();				piece.index = i;				piece.image = imageData[i];				piece.x = piece.width * (i % _columns);				piece.y = piece.height * Math.floor(i / _columns);				_pieces.push(piece);				addChild(piece as DisplayObject);			}		}				public function shuffleBoard():void {			randomize(_pieces);			for (var i:int = 0; i < _pieces.length; i++) {				movePiece(_pieces[i], i);			}		}				public function activate():void {			for each (var piece:IGamePiece in _pieces) {				piece.activate();				piece.addEventListener(MouseEvent.CLICK, pieceClicked, false, 0, true);			}		}				public function deactivate():void {			for each (var piece:IGamePiece in _pieces) {				piece.deactivate();				piece.removeEventListener(MouseEvent.CLICK, pieceClicked);			}		}				public function cleanUp():void {			_boardImage.cleanUp();			_pieces = null;		}						protected function pieceClicked(e:MouseEvent):void {			var piece:IGamePiece = e.target as IGamePiece;			if (!_selectedPiece) {				_selectedPiece = piece;			} else if (_selectedPiece == piece) {				_selectedPiece.deselect();				_selectedPiece = null;			} else {				var index:int = _selectedPiece.currentIndex;				dispatchEvent(new Event(PIECE_SWAP));				piece.deselect();				_selectedPiece.deselect();				movePiece(_selectedPiece, piece.currentIndex);				checkPiece(_selectedPiece);				movePiece(piece, index);				checkPiece(piece);				_selectedPiece = null;				checkWin();			}		}				protected function checkPiece(piece:IGamePiece):Boolean {			if (piece.currentIndex == piece.index) {				piece.removeEventListener(MouseEvent.CLICK, pieceClicked);				piece.lock();				dispatchEvent(new Event(PIECE_LOCK));				return true;			}			return false;		}				protected function checkWin():void {			var won:Boolean = true;			for each (var piece:IGamePiece in _pieces) {				if (piece.currentIndex != piece.index) won = false;			}			if (won) {				deactivate();				dispatchEvent(new Event(GAME_OVER));			}		}				protected function movePiece(piece:IGamePiece, newIndex:int):void {			piece.movePiece(piece.width * (newIndex % _columns), piece.height * Math.floor(newIndex / _columns));			piece.currentIndex = newIndex;		}						protected function randomize(vector:Vector.<IGamePiece>):Vector.<IGamePiece> {			for (var i:int = 0; i < vector.length-1; i++) {				var randomIndex:int = Math.round(Math.random()*(vector.length - 1 - i)) + i;				swapElements(vector, i, randomIndex);			}			return vector;		}				protected function swapElements(vector:Vector.<IGamePiece>,index1:int,index2:int):void {			var temp:IGamePiece =vector[index1];			vector[index1]=vector[index2];			vector[index2]=temp;			temp=null;		}					}	}